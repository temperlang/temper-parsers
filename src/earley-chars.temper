
let {...} = import("./tree");
let {...} = import("./rules");
let {...} = import("./states");
let {...} = import("./items");

export class EarleyChars {
  private rname: String;
  private parts: ListBuilder<ListBuilder<RulePart>>;
  private rules: Rules;
  private numIds: Int;
  private maxDot: Int;
  private init: String; 
  private cons: ListBuilder<fn(Listed<Tree>): Listed<Tree>>;

  public constructor(): Void {
    rname = "";
    parts = new ListBuilder<ListBuilder<RulePart>>();
    rules = new Rules();
    numIds = 0;
    maxDot = 0;
    cons = new ListBuilder<fn(Listed<Tree>): Listed<Tree>>();
  }

  let makeStateSets(start: String): StateSets {
    var rules = build();
    var found = if (start != "") {
      rules.byName[start]
    } else {
      rules.rules.toList()
    };
    var config = new StateConfig(numIds, maxDot);
    var firstSet = new StateSet(config);
    for (var i = 0; i < found.length; i++) {
      firstSet.add(found[i].toItem(0));
    }
    return new StateSets(rules.nullable, firstSet, rules.byName, cons);
  }

  public name(s: String): EarleyChars {
    for (var i = 0; i < parts.length; i++) {
      var pparts = parts[i];
      var iparts = new ListBuilder<ItemPart>();
      for (var i = 0; i < pparts.length; i++) {
        if (pparts[i].isString) {
          var tokens = new ListBuilder<Token>();
          var strs = pparts[i].data.split("");
          for (var i = 0; i < strs.length; i++) {
            var c = strs[i];
            tokens.add(new Token(c));
          }
          iparts.add(new ItemPartSet(tokens.toList()));
        } else {
          iparts.add(new ItemPartItem(pparts[i].data));
        }
      }
      if (parts[0].length > maxDot) {
        maxDot = parts[0].length;
      }
      rules.add(new Rule(rname, parts[i].toList(), numIds++, iparts.toList()));
    }
    rname = s;
    parts = new ListBuilder<ListBuilder<RulePart>>();
    return this;
  }

  public seq(): EarleyChars {
    var rnameNow = rname;
    parts.add(new ListBuilder<RulePart>());
    cons.add(fn(items: Listed<Tree>): Listed<Tree> {
      var t: Tree = new Node(rnameNow, items);
      return [t];
    });
    return this;
  }

  public ignore(): EarleyChars {
    cons[cons.length-1] = fn(items: Listed<Tree>): Listed<Tree> {
      return [];
    };
    return this;
  }

  public expand(): EarleyChars {
    cons[cons.length-1] = fn(items: Listed<Tree>): Listed<Tree> {
      return items;
    };
    return this;
  }

  public token(): EarleyChars {
    let walk(trees: Listed<Tree>): String {
      return trees.join("", fn(t: Tree): String {
        match (t) {
          is Token -> return t.as<Token>().value;
          is Node -> return walk(t.as<Node>().items);
          else -> bubble();
        }
      });
    }
    cons[cons.length-1] = fn(items: Listed<Tree>): Listed<Tree> {
      var str = walk(items);
      var tree: Tree = new Token(str);
      return [tree];
    };
    return this;
  }

  public alias(aliasName: String): EarleyChars {
    cons[cons.length-1] = fn(items: Listed<Tree>): Listed<Tree> {
      var t: Tree = new Node(aliasName, items);
      return [t];
    };
    return this;
  }

  public str(seq: String): EarleyChars {
    var split = seq.split("");
    for (var i = 0; i < split.length; i++) {
      parts[parts.length-1].add(new RulePart(true, split[i]));
    }
    return this;
  }

  public char(chr: String): EarleyChars {
    parts[parts.length-1].add(new RulePart(true, chr));
    return this;
  }

  public rule(xname: String): EarleyChars {
    parts[parts.length-1].add(new RulePart(false, xname));
    return this;
  }

  public trees(start: String, src: String): Listed<Tree> {
    var sets = makeStateSets(start);
    sets.string(src);
    var ret = new ListBuilder<Tree>();
    var last = sets.sets[sets.sets.length-1];
    for (var i = 0; i < last.length; i++) {
      var cur = last[i];
      if (cur.name == start && cur.start == 0 && cur.dot == cur.ents.length) {
        ret.addAll(cur.toTree(cons));
      }
    }
    return ret.toList();
  }

  public first(start: String, src: String): Tree {
    var sets = makeStateSets(start);
    sets.string(src);
    var ret = new ListBuilder<Tree>();
    var last = sets.sets[sets.sets.length-1];
    for (var i = 0; i < last.length; i++) {
      var cur = last[i];
      if (cur.name == start && cur.start == 0 && cur.dot == cur.ents.length) {
        ret.addAll(cur.toTree(cons));
      }
    }
    return ret[0];
  }

  public lex(src: String): Listed<Token> {
    var got = makeStateSets("__token__");
    var split = src.split("");
    var ret = new ListBuilder<Token>();
    var start = 0;
    while (start < split.length) {
      var end = got.token(start, split);
      if (end == start) {
        console.log("error: cannot lex: \"${split[start]}\"");
        return ret;
      }
      var j = new ListBuilder<String>();
      while (start < end) {
        j.add(split[start++]);
      }
      var data = j.join("") { (s);; s };
      console.log(data);
      ret.add(new Token(data));
    }
    return ret;
  }

  public all(start: String, src: String): Listed<Tree> {
    var sets = makeStateSets(start);
    sets.string(src);
    var ret = new ListBuilder<Tree>();
    for (var i = 0; i < sets.sets.length; i++) {
      var last = sets.sets[i];
      for (var j = 0; j < last.length; j++) {
        var cur = last[j];
        if (cur.name == start && cur.dot == cur.ents.length) {
          ret.addAll(cur.toTree(cons));
        }
      }
    }
    return ret.toList();
  }

  public allTrees(src: String): Listed<Tree> {
    var sets = makeStateSets("");
    sets.string(src);
    var ret = new ListBuilder<Tree>();
    var last = sets.sets[sets.sets.length-1];
    for (var i = 0; i < last.length; i++) {
      var cur = last[i];
      if (cur.start == 0 && cur.dot == cur.ents.length) {
        var trees = cur.toTree(cons);
        ret.add(new Node(cur.name, trees));
      }
    }
    return ret.toList();
  }

  private build(): Rules {
    name("");
    var got = rules.build();
    for (var i = 0; i < got.length; i++) {
      console.log("undefined: ${got[i]}");
    }
    return rules;
  }

  public toString(): String {
    return build().toString();
  }
}
