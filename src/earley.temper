
let {...} = import("./tree.temper");
let {...} = import("./rules.temper");
let {...} = import("./states.temper");
let {...} = import("./items.temper");

let makeStateSets(rules: Rules, start: String): StateSets {
  var found = if (start != "") {
    rules.byName[start]
  } else {
    rules.rules.toList()
  };
  var firstSet = new StateSet();
  for (var i = 0; i < found.length; i++) {
    firstSet.add(found[i].toItem(0));
  }
  var nullable = new DenseBitVector(rules.nullable.length);
  for (var i = 0; i < rules.nullable.length; i++) {
    nullable[i] = rules.nullable[i];
  }
  return new StateSets(nullable, firstSet, rules.byName);
}

export class Earley {
  private rname: String;
  private parts: ListBuilder<ListBuilder<RulePart>>;
  private consBy: ListBuilder<fn(Listed<Tree>): Listed<Tree>>;
  private rules: Rules;
  private nid: Int;
  private init: String; 

  public constructor(): Void {
    rname = "";
    consBy = new ListBuilder<fn(Listed<Tree>): Listed<Tree>>();
    parts = new ListBuilder<ListBuilder<RulePart>>();
    rules = new Rules();
    nid = 0;
  }

  public name(s: String): Earley {
    for (var i = 0; i < parts.length; i++) {
      var pparts = parts[i];
      var iparts = new ListBuilder<ItemPart>();
      for (var i = 0; i < pparts.length; i++) {
        if (pparts[i].isString) {
          iparts.add(new ItemPartSet(pparts[i].data.split("")));
        } else {
          iparts.add(new ItemPartItem(pparts[i].data));
        }
      }
      rules.add(new Rule(rname, parts[i].toList(), nid++, consBy[i], iparts.toList()));
    }
    rname = s;
    consBy = new ListBuilder<fn(Listed<Tree>): Listed<Tree>>();
    parts = new ListBuilder<ListBuilder<RulePart>>();
    return this;
  }

  public seq(): Earley {
    var rnameNow = rname;
    parts.add(new ListBuilder<RulePart>());
    consBy.add(fn(items: Listed<Tree>): List<Tree> {
      return [new Node(rnameNow, items)];
    });
    return this;
  }

  public cons(cons: fn(Listed<Tree>): Listed<Tree>): Earley {
    consBy[consBy.length-1] = cons;
    return this;
  }

  public ignore(): Earley {
    consBy[consBy.length-1] = fn(items: Listed<Tree>): Listed<Tree> {
      return [];
    };
    return this;
  }

  public expand(): Earley {
    consBy[consBy.length-1] = fn(items: Listed<Tree>): Listed<Tree> {
      return items;
    };
    return this;
  }

  public token(): Earley {
    let walk(trees: Listed<Tree>): String {
      return trees.join("", fn(t: Tree): String {
        match (t) {
          is Token -> return t.as<Token>().value;
          is Node -> return walk(t.as<Node>().items);
          else -> bubble();
        }
      });
    }
    consBy[consBy.length-1] = fn(items: Listed<Tree>): List<Tree> {
      return [new Token(walk(items))];
    };
    return this;
  }

  public alias(aliasName: String): Earley {
    consBy[consBy.length-1] = fn(items: Listed<Tree>): List<Tree> {
      return [new Node(aliasName, items)];
    };
    return this;
  }

  public str(seq: String): Earley {
    var split = seq.split("");
    for (var i = 0; i < split.length; i++) {
      parts[parts.length-1].add(new RulePart(true, split[i]));
    }
    return this;
  }

  public char(chr: String): Earley {
    parts[parts.length-1].add(new RulePart(true, chr));
    return this;
  }

  public rule(xname: String): Earley {
    parts[parts.length-1].add(new RulePart(false, xname));
    return this;
  }

  public debug(src: String): Void {
    var sets = makeStateSets(build(), "");
    var split = src.split("");
    sets.chars(split);
    for (var j = 0; j < sets.sets.length; j++) {
      var c = split[j] orelse "<none>";
      console.log("=== ${j.toString()} (char: ${c}) ===");
      var last = sets.sets[j];
      for (var i = 0; i < last.length; i++) {
        console.log(last[i].toString());
      }
    }
  }

  public parse(src: String): Void {
    var sets = makeStateSets(build(), "");
    sets.string(src);
    var last = sets.sets[sets.sets.length-1];
    for (var i = 0; i < last.length; i++) {
      console.log(last[i].toString());
    }
  }

  public trees(start: String, src: String): List<Tree> {
    var sets = makeStateSets(build(), start);
    sets.string(src);
    var ret = new ListBuilder<Tree>();
    var last = sets.sets[sets.sets.length-1];
    for (var i = 0; i < last.length; i++) {
      var cur = last[i];
      if (cur.name == start && cur.start == 0 && cur.dot == cur.ents.length) {
        ret.addAll(cur.toTree());
      }
    }
    return ret.toList();
  }

  public first(start: String, src: String): Tree | Bubble {
    var sets = makeStateSets(build(), start);
    sets.string(src);
    var ret = new ListBuilder<Tree>();
    var last = sets.sets[sets.sets.length-1];
    for (var i = 0; i < last.length; i++) {
      var cur = last[i];
      if (cur.name == start && cur.start == 0 && cur.dot == cur.ents.length) {
        ret.addAll(cur.toTree());
      }
    }
    return ret.getOr(0, new Token("ERROR"));
  }

  public all(start: String, src: String): List<Tree> {
    var sets = makeStateSets(build(), start);
    sets.string(src);
    var ret = new ListBuilder<Tree>();
    for (var i = 0; i < sets.sets.length; i++) {
      var last = sets.sets[i];
      for (var j = 0; j < last.length; j++) {
        var cur = last[j];
        if (cur.name == start && cur.dot == cur.ents.length) {
          ret.addAll(cur.toTree());
        }
      }
    }
    return ret.toList();
  }

  public allTrees(src: String): List<Tree> {
    var sets = makeStateSets(build(), "");
    sets.string(src);
    var ret = new ListBuilder<Tree>();
    var last = sets.sets[sets.sets.length-1];
    for (var i = 0; i < last.length; i++) {
      var cur = last[i];
      if (cur.start == 0 && cur.dot == cur.ents.length) {
        ret.addAll(cur.toTree());
      }
    }
    return ret.toList();
  }

  public build(): Rules {
    name("");
    var got = rules.build();
    for (var i = 0; i < got.length; i++) {
      console.log("undefined: ${got[i]}");
    }
    return rules;
  }

  public toString(): String {
    return build().toString();
  }
}
