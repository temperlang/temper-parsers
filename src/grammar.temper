
let {...} = import("./earley-tokens");
let {...} = import("./tree");
let {...} = import("./ascii");

class LexerTable {
  public next: Map<String, LexerTable>;
  public ended: Token;
}

class Lexer {
  private n: Int;
  private table: LexerTable;

  public constructor(): Void {
    n = 0;
  }

  public lex(s: String): Listed<Token> {
    var ret = new ListBuilder<Token>();
    return ret;
  }

  public genName(): String {
    n += 1;
    return "#${n.toString()}";
  }

  public def(node: Node): String | Bubble {
    var name = genName();
    if (node.type == "AliasDefine") {
    }
    if (node.type == "Define") {
    }
    if (node.type == "Select") {
    }
    if (node.type == "Sequence") {
    }
    if (node.type == "OneOrMore") {
    }
    if (node.type == "ZeroOrMore") {
    }
    if (node.type == "ZeroOrOne") {
    }
    if (node.type == "Rule") {
    }
    if (node.type == "CharSet") {
    }
    if (node.type == "String") {
    }
    if (node.type == "TokenString") {
    }
    console.log("unhandled: /${node.type}/ -> ${node.toString()}");
    return bubble();
  }
}

export class Grammar {
  public earley: EarleyTokens;
  public lexer: Lexer;
  private term: Boolean;
  private base: String;
  private n: Int;

  public constructor(): Void {
    earley = new EarleyTokens();
    lexer = new Lexer();
    base = "";
    term = false;
    n = 0;
  }

  private genName(): String {
    n += 1;
    return "${base}#${n.toString()}";
  }

  private translateNode(node: Node, cb: fn(String): Void): Void {
    var earley = earley;
    var self = this;
    if (node.type == "Grammar") {
      node.forEach { (tree);;
        self.translate(tree) { (item);; };
      };
      cb("");
      return;
    } 
    if (node.type == "AliasDefine") {
      var alias = node.items[2].as<Token>().value;
      var name = node.items[0].as<Token>().value;
      if (name.codePoints.read() <= "Z".codePoints.read()) {
        var got = lexer.def(node);
        earley.name(name).seq().token(got).alias(alias);
        cb("");
      } else {
        self.translate(node.items[1]) { (item);;
          earley.name(name).seq().rule(item).alias(alias);
          cb("");
        };
      }
      return;
    } 
    if (node.type == "Define") {
      var name = node.items[0].as<Node>();
      var base = name.items[0].as<Token>().value;
      var expand = name.type == "ExpandName";
      if (base.codePoints.read() <= "Z".codePoints.read()) {

      } else {
        self.translate(node.items[1]) { (item);;
          earley.name(base).seq().rule(item);
          if (expand) {
            earley.expand();
          }
          cb("");
        };
      }
      return;
    } 
    if (node.type == "Rule") {
      cb(node.items[0].as<Token>().value);
      return;
    } 
    var name = genName();
    if (node.type == "Select") {
      var names = new ListBuilder<String>();
      node.forEach { (tree);;
        self.translate(tree) { (item);;
          names.add(item);
          if (names.length == node.items.length) {
            earley.name(name);
            for (var i = 0; i < names.length; i++) {
              earley.seq().rule(names[i]).expand();
            }
            cb(name);
          }
        };
      };
      return;
    } 
    if (node.type == "Sequence") {
      var names = new ListBuilder<String>();
      node.forEach { (tree);;
        self.translate(tree) { (item);;
          names.add(item);
          if (names.length == node.items.length) {
            earley.name(name).seq();
            for (var i = 0; i < names.length; i++) {
              if (i != 0) {
                earley.rule("__ignores__");
              }
              earley.rule(names[i]);
            }
            earley.expand();
            cb(name);
          }
        };
      };
      return;
    } 
    if (node.type == "OneOrMore") {
      self.translate(node.items[0]) { (item);;
        earley.name(name)
          .seq().rule(name).rule("__ignores__").rule(item).expand()
          .seq().rule(item).expand();
        cb(name);
      };
      return;
    } 
    if (node.type == "ZeroOrMore") {
      self.translate(node.items[0]) { (item);;
        earley.name(name)
          .seq().rule(name).rule("__ignores__").rule(item).expand()
          .seq().expand();
        cb(name);
      };
      return;
    }
    if (node.type == "ZeroOrOne") {
      self.translate(node.items[0]) { (item);;
        earley.name(name)
          .seq().rule(item).expand()
          .seq().expand();
        cb(name);
      };
      return;
    } 
    if (node.type == "CharSet") {
      earley.name(name).seq().token(lexer.def(node)).expand();
      cb(name);
      return;
    }
    if (node.type == "String") {
      earley.name(name).seq().token(lexer.def(node)).ignore();
      cb(name);
      return;
    }
    if (node.type == "TokenString") {
      earley.name(name).seq().token(lexer.def(node)).expand();
      cb(name);
      return;
    }
    console.log("unhandled: /${node.type}/ -> ${node.toString()}");
    bubble();
  }

  public translate(tree: Tree, cb: fn(String): Void): Void {
    match (tree) {
      is Node -> translateNode(tree.as<Node>(), cb);
      else -> do {
        console.log("unhandled: ${tree.toString()}");
      };
    }
  }

  public addTree(whole: Tree): Void {
    translate(whole) { (item);; };
  }
}

