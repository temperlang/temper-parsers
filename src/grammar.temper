
let { Earley } = import("./earley");
let { Tree, Node, Token } = import("./tree");

var digits = "0123456789";
var lowercase = "abcdefghijklmnopqrstuvwxyz";
var uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var alpha = "${lowercase}${uppercase}";
var alnum = "${alpha}${digits}";
var word0 = "${alpha}_";
var word1 = "${word0}${digits}";
let stringBody = " !#$%&()*+,-./${digits}:;<=>?@${uppercase}[]^_`${lowercase}{|}~";
let ascii = "${stringBody}\\\"";

export let larkish(): Earley {
  var ret = new Earley();
  ret.name("Grammar")
    .seq().rule("Ignore").rule("Defines").rule("Ignore");
  ret.name("Defines")
    .seq().rule("Defines").rule("Ignore").rule("Define").expand()
    .seq().rule("Define").expand();
  ret.name("Define")
    .seq().rule("DefineName").rule("Ignore").rule("CharColon").rule("Ignore").rule("Pattern")
    .seq().rule("Name").rule("Ignore").rule("CharColon").rule("Ignore").rule("Pattern").rule("Ignore").rule("AliasArrow").rule("Ignore").rule("Name").alias("AliasDefine");
  ret.name("Pattern")
    .seq().rule("Select").expand();
  ret.name("Select")
    .seq().rule("SelectBody");
  ret.name("SelectBody")
    .seq().rule("SelectBody").rule("Ignore").rule("CharPipe").rule("Ignore").rule("Sequence").expand()
    .seq().rule("Sequence").expand();
  ret.name("Sequence")
    .seq().rule("SequenceBody");
  ret.name("SequenceBody")
    .seq().rule("SequenceBody").rule("Ignore").rule("Postfix").expand()
    .seq().rule("Postfix").expand();
  ret.name("Postfix")
    .seq().rule("Single").rule("Ignore").rule("CharPlus").alias("OneOrMore")
    .seq().rule("Single").rule("Ignore").rule("CharTimes").alias("ZeroOrMore")
    .seq().rule("Single").rule("Ignore").rule("CharQuestion").alias("ZeroOrOne")
    .seq().rule("Single").rule("Ignore").rule("CharCaret").alias("ToExpand")
    .seq().rule("Single").expand();
  ret.name("Single")
    .seq().rule("CharOpenParen").rule("Ignore").rule("Pattern").rule("Ignore").rule("CharCloseParen").expand()
    .seq().rule("Name").alias("Rule")
    .seq().rule("CharQuotes").rule("StringBody").rule("CharQuotes").alias("String")
    .seq().rule("CharQuotes").rule("StringBody").rule("CharQuotes").rule("CharBang").alias("TokenString")
    .seq().rule("CharOpenSquare").rule("StringBody").rule("CharCloseSquare").alias("CharSet")
    .seq().rule("CharHashtag").char(ascii).alias("CharSet");
  ret.name("StringBody")
    .seq().rule("StringData").token();
  ret.name("StringData")
    .seq().rule("StringData").rule("StringChar").expand()
    .seq().char(stringBody).expand();
  ret.name("StringChar")
    .seq().char(stringBody)
    .seq().rule("CharBackslash").rule("StringEscape").expand();
  ret.name("StringEscape")
    .seq().char("\"\'rtn")
    .seq().char("x").char(digits).char(digits);
  ret.name("DefineName")
    .seq().rule("Name").rule("Ignore").rule("CharQuestion").alias("ExpandName")
    .seq().rule("Name").alias("Name");
  ret.name("Name")
    .seq().rule("Letters").token();
  ret.name("Letters")
    .seq().rule("Letters").char("${alpha}_.").expand()
    .seq().char(alpha).expand();
  ret.name("Ignore")
    .seq().rule("IgnoreChars").ignore()
    .seq().ignore();
  ret.name("IgnoreChars")
    .seq().rule("IgnoreChars").char(" \t\r\n")
    .seq().char(" \t\r\n");
  ret.name("AliasArrow").seq().str("->").ignore();
  ret.name("CharCaret").seq().str("^").ignore();
  ret.name("CharQuotes").seq().char("\"").ignore();
  ret.name("CharColon").seq().char(":").ignore();
  ret.name("CharPipe").seq().char("|").ignore();
  ret.name("CharPlus").seq().char("+").ignore();
  ret.name("CharTimes").seq().char("*").ignore();
  ret.name("CharQuestion").seq().char("?").ignore();
  ret.name("CharBang").seq().char("!").ignore();
  ret.name("CharOpenParen").seq().char("(").ignore();
  ret.name("CharCloseParen").seq().char(")").ignore();
  ret.name("CharOpenSquare").seq().char("[").ignore();
  ret.name("CharCloseSquare").seq().char("]").ignore();
  ret.name("CharBackslash").seq().char(")").ignore();
  ret.name("CharHashtag").seq().char("#").ignore();
  return ret;
}

export let toEarley(whole: Tree): Earley {
  var earley = new Earley();

  var base = "";
  var term: Boolean = false;
  var n = 0;
  let genName(): String {
    n += 1;
    return "${base}#${n.toString()}";
  }

  let translateNode(node: Node, cb: fn(String): Void): Void {
    if (node.type == "Grammar") {
      node.forEach { (tree);;
        translate(tree) { (name);; };
      };
      cb("");
      return;
    } 
    if (node.type == "AliasDefine") {
      var alias = node.items[2].as<Token>().value;
      var name = node.items[0].as<Token>().value;
      term = name.codePoints.read() <= "Z".codePoints.read();
      translate(node.items[1]) { (item);;
        earley.name(name).seq().rule(item);
        if (term) {
          earley.token();
        } else {
          earley.alias(alias);
        }
        cb("");
      };
      return;
    } 
    if (node.type == "Define") {
      var name = node.items[0].as<Node>();
      var base = name.items[0].as<Token>().value;
      var expand = name.type == "ExpandName";
      term = base.codePoints.read() <= "Z".codePoints.read();
      translate(node.items[1]) { (item);;
        earley.name(base).seq().rule(item);
        if (expand) {
          earley.expand();
        }
        if (term) {
          earley.token();
        }
        cb("");
      };
      return;
    } 
    if (node.type == "Select") {
      var name = genName();
      var names = new ListBuilder<String>();
      node.forEach { (tree);;
        translate(tree) { (item);;
          names.add(item);
          if (names.length == node.items.length) {
            earley.name(name);
            for (var i = 0; i < names.length; i++) {
              earley.seq().rule(names[i]).expand();
            }
            cb(name);
          }
        };
      };
      return;
    } 
    if (node.type == "Sequence") {
      var name = genName();
      var names = new ListBuilder<String>();
      node.forEach { (tree);;
        translate(tree) { (item);;
          names.add(item);
          if (names.length == node.items.length) {
            earley.name(name).seq();
            for (var i = 0; i < names.length; i++) {
              if (i != 0) {
                if (!term) {
                  earley.rule("__ignores__");
                }
              }
              earley.rule(names[i]);
            }
            earley.expand();
            cb(name);
          }
        };
      };
      return;
    } 
    if (node.type == "OneOrMore") {
      var name = genName();
      translate(node.items[0]) { (item);;
        if (!term) {
          earley.name(name).seq().rule(name).rule("__ignores__").rule(item).expand();
        } else {
          earley.name(name).seq().rule(name).rule(item).expand();
        }
        earley.name(name).seq().rule(item).expand();
        cb(name);
      };
      return;
    } 
    if (node.type == "ZeroOrMore") {
      var name = genName();
      translate(node.items[0]) { (item);;
        if (!term) {
          earley.name(name).seq().rule(name).rule("__ignores__").rule(item).expand();
        } else {
          earley.name(name).seq().rule(name).rule(item).expand();
        }
        earley.name(name).seq().expand();
        cb(name);
      };
      return;
    } 
    if (node.type == "ToIgnore") {
      var name = genName();
      translate(node.items[0]) { (item);;
        earley.name(name).seq().rule(item).ignore();
        cb(name);
      };
      return;
    }
    if (node.type == "ToExpand") {
      var name = genName();
      translate(node.items[0]) { (item);;
        earley.name(name).seq().rule(item).expandMore();
        cb(name);
      };
      return;
    }
    if (node.type == "ZeroOrOne") {
      var name = genName();
      translate(node.items[0]) { (item);;
        earley.name(name).seq().rule(item).expand();
        earley.name(name).seq().expand();
        cb(name);
      };
      return;
    } 
    if (node.type == "Rule") {
      cb(node.items[0].as<Token>().value);
      return;
    } 
    if (node.type == "CharSet") {
      var name = genName();
      earley.name(name).seq().char(node.items[0].as<Token>().value).token();
      cb(name);
      return;
    }
    if (node.type == "String") {
      var name = genName();
      earley.name(name).seq().str(node.items[0].as<Token>().value).ignore();
      cb(name);
      return;
    }
    if (node.type == "TokenString") {
      var name = genName();
      earley.name(name).seq().str(node.items[0].as<Token>().value).token();
      cb(name);
      return;
    }
    console.log("unhandled: /${node.type}/ -> ${node.toString()}");
    bubble();
  }

  let translate(tree: Tree, cb: fn(String): Void): Void {
    match (tree) {
      is Node -> translateNode(tree.as<Node>(), cb);
      else -> do {
        console.log("unhandled: ${tree.toString()}");
      };
    }
  }

  translate(whole) { (name);; };

  earley.name("__start__").seq().rule("__ignores__").rule("start").rule("__ignores__").expand();
  earley.name("__ignores__").seq().rule("__ignores__").rule("ignore").ignore();
  earley.name("__ignores__").seq().rule("ignore").ignore();
  earley.name("ignore").seq().ignore();

  earley.name("DIGIT").seq().char(digits).token();
  earley.name("DIGITS").seq().char(digits).rule("DIGITS").token();
  earley.name("DIGITS").seq().char(digits).token();
  earley.name("LOWERCASE").seq().char(lowercase).token();
  earley.name("UPPERCASE").seq().char(uppercase).token();
  earley.name("LETTER").seq().char(alpha).token();
  earley.name("LETTERS").seq().char(alpha).rule("LETTERS").token();
  earley.name("LETTERS").seq().char(alpha).token();
  earley.name("ASCII").seq().char(ascii).token();
  earley.name("CNAME").seq().rule("CNAME").char(word1).token();
  earley.name("CNAME").seq().char(word0).token();
  earley.name("WHITESPACE").seq().char(" \t\r\n").token();

  return earley;
}

