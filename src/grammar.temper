
let {...} = import("./earley-tokens");
let {...} = import("./earley-chars");
let {...} = import("./tree");
let {...} = import("std/regex");

class Lexer {
  private n: Int;
  private earley: EarleyChars;

  public constructor(): Void {
    n = 0;
    earley = new EarleyChars();
  }

  public lex(src: String): Listed<Token> {
    return earley.lex(src);
  }

  public genName(): String {
    n += 1;
    return "#${n.toString()}";
  }

  public defCharSet(name: String, charSet: String): String {
    earley.name(name).seq().char(charSet);
    earley.name("__token__").seq().rule(name);
    return name;
  }

  public fromString(str: String): String {
    var name = genName();
    earley.name(name).seq().str(str);
    earley.name("__token__").seq().rule(name);
    return name;
  }

  public fromCharSet(str: String): String {
    var name = genName();
    earley.name(name).seq().char(str);
    earley.name("__token__").seq().rule(name);
    return name;
  }

  public from(node: Node): String {
    var earley = earley;
    var self = this;
    var name = genName();
    if (node.type == "Select") {
      var rules = new ListBuilder<String>();
      node.forEach { (it);;
        var got = self.from(it.as<Node>());
        earley.name(name).seq().rule(got);
      };
      return name;
    }
    if (node.type == "Sequence") {
      var rules = new ListBuilder<String>();
      node.forEach { (it);;
        rules.add(self.from(it.as<Node>()));
      };
      var chain = earley.name(name).seq();
      for (var i = 0; i < rules.length; i++) {
        chain = chain.rule(rules[i]);
      }
      return name;
    }
    if (node.type == "OneOrMore") {
      var got = from(node.items[0].as<Node>());
      earley.name(name).seq().rule(name).rule(got);
      earley.name(name).seq().rule(name);
      return name;
    }
    if (node.type == "ZeroOrMore") {
      var got = from(node.items[0].as<Node>());
      earley.name(name).seq().rule(name).rule(got);
      earley.name(name).seq();
      return name;
    }
    if (node.type == "ZeroOrOne") {
      var got = from(node.items[0].as<Node>());
      earley.name(name).seq().rule(got);
      earley.name(name).seq();
      return name;
    }
    if (node.type == "Rule") {
      earley.name(name).seq().rule(node.items[0].as<Token>().value);
      return name;
    }
    if (node.type == "CharSet") {
      earley.name(name).seq().char(node.items[0].as<Token>().value);
      return name;
    }
    if (node.type == "String") {
      earley.name(name).seq().str(node.items[0].as<Token>().value);
      earley.name("__token__").seq().rule(name);
      return name;
    }
    if (node.type == "TokenString") {
      earley.name(name).seq().str(node.items[0].as<Token>().value);
      earley.name("__token__").seq().rule(name);
      return name;
    }
    console.log("unhandled: /${node.type}/ -> ${node.toString()}");
    return "";
  }

  public def(name: String, node: Node): String {
    var got = from(node);
    earley.name(name).seq().rule(got);
    earley.name("__token__").seq().rule(name);
    return name;
  }
}

export class Grammar {
  public earley: EarleyTokens;
  public lexer: Lexer;
  private term: Boolean;
  private n: Int;

  public constructor(): Void {
    earley = new EarleyTokens();
    lexer = new Lexer();
    term = false;
    n = 0;
  }

  private lex(str: String): Listed<Token> {
    return lexer.lex(str);
  }

  private genName(): String {
    n += 1;
    return "#${n.toString()}";
  }

  private translateNode(node: Node, cb: fn(String): Void): Void {
    var earley = earley;
    var self = this;
    if (node.type == "Grammar") {
      node.forEach { (tree);;
        self.translate(tree) { (item);; };
      };
      cb("");
      return;
    } 
    if (node.type == "AliasDefine") {
      var alias = node.items[2].as<Token>().value;
      var name = node.items[0].as<Token>().value;
      if (name.codePoints.read() <= "Z".codePoints.read()) {
        earley.name(name).seq().token(lexer.def(name, node.items[1].as<Node>())).alias(alias);
        cb("");
      } else {
        self.translate(node.items[1]) { (item);;
          earley.name(name).seq().rule(item).alias(alias);
          cb("");
        };
      }
      return;
    } 
    if (node.type == "Define") {
      var item0 = node.items[0].as<Node>();
      var name = item0.items[0].as<Token>().value;
      var expand = item0.type == "ExpandName";
      if (name.codePoints.read() <= "Z".codePoints.read()) {
        earley.name(name).seq().token(lexer.def(name, node.items[1].as<Node>()));
        if (expand) {
          earley.expand();
        }
        cb("");
      } else {
        self.translate(node.items[1]) { (item);;
          earley.name(name).seq().rule(item);
          if (expand) {
            earley.expand();
          }
          cb("");
        };
      }
      return;
    } 
    if (node.type == "Rule") {
      cb(node.items[0].as<Token>().value);
      return;
    } 
    var name = genName();
    if (node.type == "Select") {
      var names = new ListBuilder<String>();
      node.forEach { (tree);;
        self.translate(tree) { (item);;
          names.add(item);
          if (names.length == node.items.length) {
            earley.name(name);
            for (var i = 0; i < names.length; i++) {
              earley.seq().rule(names[i]).expand();
            }
            cb(name);
          }
        };
      };
      return;
    } 
    if (node.type == "Sequence") {
      var names = new ListBuilder<String>();
      node.forEach { (tree);;
        self.translate(tree) { (item);;
          names.add(item);
          if (names.length == node.items.length) {
            earley.name(name).seq();
            for (var i = 0; i < names.length; i++) {
              earley.rule(names[i]);
            }
            earley.expand();
            cb(name);
          }
        };
      };
      return;
    } 
    if (node.type == "OneOrMore") {
      self.translate(node.items[0]) { (item);;
        earley.name(name)
          .seq().rule(name).rule(item).expand()
          .seq().rule(item).expand();
        cb(name);
      };
      return;
    } 
    if (node.type == "ZeroOrMore") {
      self.translate(node.items[0]) { (item);;
        earley.name(name)
          .seq().rule(name).rule(item).expand()
          .seq().expand();
        cb(name);
      };
      return;
    }
    if (node.type == "ZeroOrOne") {
      self.translate(node.items[0]) { (item);;
        earley.name(name)
          .seq().rule(item).expand()
          .seq().expand();
        cb(name);
      };
      return;
    } 
    if (node.type == "CharSet") {
      earley.name(name).seq().token(lexer.fromCharSet(node.items[0].as<Token>().value)).expand();
      cb(name);
      return;
    }
    if (node.type == "String") {
      earley.name(name).seq().token(lexer.fromString(node.items[0].as<Token>().value)).ignore();
      cb(name);
      return;
    }
    if (node.type == "TokenString") {
      earley.name(name).seq().token(lexer.fromString(node.items[0].as<Token>().value)).expand();
      cb(name);
      return;
    }
    console.log("unhandled: /${node.type}/ -> ${node.toString()}");
    bubble();
  }

  public translate(tree: Tree, cb: fn(String): Void): Void {
    match (tree) {
      is Node -> translateNode(tree.as<Node>(), cb);
      else -> do {
        console.log("unhandled: ${tree.toString()}");
        bubble();
      };
    }
  }

  public addCharSet(name: String, value: String): Void {
    earley.name(name).seq().token(lexer.defCharSet(name, value)).ignore();
  }

  public addTree(whole: Tree): Void {
    translate(whole) { (item);; };
  }
}

