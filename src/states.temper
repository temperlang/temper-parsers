

let {...} = import("./items");
let {...} = import("./rules");
let {...} = import("./tree");

export class StateConfig {
  public numIds: Int;
  public maxDot: Int;
}

var emptyItemList: List<Item> = [];
var emptyItemPart: ItemPart = new ItemPartSet([]);

export class StateSet {
  public nexts: MapBuilder<String, ListBuilder<Item>>;
  public config: StateConfig;
  private setv: ListBuilder<Item>;
  private hashes: MapBuilder<Int, Item | Null>;

  public constructor(conf: StateConfig, v: ListBuilder<Item>) {
    setv = v;
    nexts = new MapBuilder<String, ListBuilder<Item>>();
    hashes = new MapBuilder<Int, ListBuilder<Item>>();
    config = conf;
  }

  public clear(): Int {
    var len = setv.length;
    setv = new ListBuilder<Item>();
    hashes = new MapBuilder<String, ListBuilder<Item>>();
    return len;
  }
  
  public add(next: Item): Boolean {
    var hash
      = next.id
      + (next.dot + next.start * config.maxDot) * config.numIds;
    var got = hashes.getOr(hash, null);
    if (got != null) {
      return false;
    }
    hashes[hash] = next;
    if (next.dot < next.ents.length) {
      var ent = next.ents.getOr(next.dot, emptyItemPart);
      if (!ent.isTest()) {
        var at = ent.name(); 
        var nextv = nexts.getOr(at, new ListBuilder<Item>());
        if (nextv.length == 0) {
          nexts[at] = nextv;
        }
        nextv.add(next);
      }
    }
    setv.add(next);
    return true;
  }

  public get(i: Int): Item {
    return setv[i];
  }

  public get length(): Int {
    return setv.length;
  }
}

let walk(trees: Listed<Tree>): String {
  return trees.join("", fn(t: Tree): String {
    match (t) {
      is Token -> return t.as<Token>().value;
      is Node -> return walk(t.as<Node>().items);
      else -> bubble();
    }
  });
}

export class StateSets {
  public nullable: DenseBitVector;
  public byName: Mapped<String, Listed<Rule>>;
  public sets: ListBuilder<StateSet>;
  public cons: Listed<fn(Listed<Tree>): Listed<Tree>>;

  public constructor(n: DenseBitVector, s: StateSet, b: Mapped<String, Listed<Rule>>, c: Listed<fn(Listed<Tree>): Listed<Tree>>): Void {
    nullable = n;
    byName = b;
    sets = new ListBuilder<StateSet>();
    sets.add(s);
    cons = c;
  }

  private process1(i: Int, next: StateSet, token: Token): Void {
    var last = sets[i];
    for (var j = 0; j < last.length; j++) {
      var item = last[j];
      var ilen = item.ents.length;
      if (item.dot < ilen) {
        var ent = item.ents[item.dot];
        if (ent.isTest()) {
          if (ent.check(token)) {
            next.add(item.advanceWithSingle(token));
          }
        } else {
          var name = ent.name();
          var found = byName[name];
          var flen = found.length;
          var noMagic = true;
          for (var k = 0; k < flen; k++) {
            var cur = found[k];
            var itemFound = cur.toItem(i);
            last.add(itemFound);
            if (nullable[cur.id]) {
              var magic = item.advance();
              last.add(magic);
              noMagic = false;
            }
          }
        }
      } else {
        var trees = item.toTree(cons);
        var olds = sets[item.start].nexts.getOr(item.name, new ListBuilder<Item>());
        var olen = olds.length;
        for (var k = 0; k < olen; k++) {
          last.add(olds[k].advanceWith(trees));
        }
      }
    }
  }

  public string(str: String): Void {
    var config = sets[0].config;
    var split = str.split("");
    var len = split.length;
    for (var i = 0; i < len; i++) {
      var next = new StateSet(config, new ListBuilder<Item>());
      process1(sets.length-1, next, new Token(split[i]));
      if (next.length == 0) {
        console.log("Error at char#${i.toString()} (char: ${split[i]})");
        return;
      }
      sets[sets.length-1].clear();
      sets.add(next);
    }
    var next = new StateSet(config, new ListBuilder<Item>());
    process1(sets.length-1, next, new Token(""));
  }

  public token(start: Int, split: List<String>): Int {
    var firstSet = sets[0];
    var len = split.length;
    for (var cur = start; cur < len; cur++) {
      var next = new StateSet(firstSet.config, new ListBuilder<Item>());
      process1(sets.length-1, next, new Token(split[cur]));
      if (next.length == 0) {
        return cur;
      }
      sets.add(next);
    }
    return len;
  }
}
