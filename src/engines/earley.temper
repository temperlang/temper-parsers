
let {...} = import("../common/items");
let {...} = import("../common/rules");
let {...} = import("../common/tree");
let {...} = import("./lexer");

export class EarleyConfig {
  public numIds: Int;
  public maxDot: Int;
}

var emptyItemList: List<Item> = [];
var emptyItemPart: ItemPart = new ItemPartSet([]);

export class EarleyStateSet {
  public nexts: MapBuilder<String, ListBuilder<Item>>;
  public config: EarleyConfig;
  private setv: ListBuilder<Item>;
  private hashes: MapBuilder<Int, Boolean>;

  public constructor(conf: EarleyConfig) {
    setv = new ListBuilder<Item>();
    nexts = new MapBuilder<String, ListBuilder<Item>>();
    hashes = new MapBuilder<Int, Boolean>();
    config = conf;
  }

  public clear(): Int {
    var len = setv.length;
    setv = new ListBuilder<Item>();
    hashes = new MapBuilder<Int, Boolean>();
    return len;
  }

  public clearReport(): String {
    var nums = new MapBuilder<String, Int>();
    for (var i = 0; i < setv.length; i++) {
      var c = setv[i];
      nums[c.name] = nums.getOr(c.name, 0) + 1;
    }
    var s = new ListBuilder<String>();
    nums.forEach { (k: String, v: Int): Void;;
      s.add("${v.toString()}: ${k}");
    };
    return s.join("\n", fn(s: String): String {s});
  }
  
  public add(next: Item): Boolean {
    var hash
      = next.id
      + (next.dot + next.start * config.maxDot) * config.numIds;
    if (hashes.getOr(hash, false)) {
      return false;
    }
    hashes[hash] = true;
    var ent = next.ents.getOr(next.dot, emptyItemPart);
    if (!ent.isTest()) {
      var at = ent.name(); 
      var nextv = nexts.getOr(at, new ListBuilder<Item>());
      if (nextv.length == 0) {
        nexts[at] = nextv;
      }
      nextv.add(next);
    }
    setv.add(next);
    return true;
  }

  public get(i: Int): Item {
    return setv[i];
  }

  public get length(): Int {
    return setv.length;
  }
}

let ord(c: String): Int {
  return c.codePoints.read();
}

let idString(s: String): String {
  return s;
}

var nonTestItemEntry = new ItemPartItem("does not matter");

var wordCharCodes = new DenseBitVector(127);

for (var i = 65; i <= 90; i++) {
  wordCharCodes[i] = true;
}

wordCharCodes[95] = true;

for (var i = 97; i <= 122; i++) {
  wordCharCodes[i] = true;
}

export interface Earley {
  public trees(src: String): Listed<Tree>;
}

export class CharEarley extends Earley {
  private start: String;
  private nullable: DenseBitVector;
  private byName: Mapped<String, Listed<Rule>>;
  private sets: ListBuilder<EarleyStateSet>;

  public constructor(s: String, n: DenseBitVector, e: EarleyStateSet, b: Mapped<String, Listed<Rule>>): Void {
    start = s;
    nullable = n;
    byName = b;
    sets = new ListBuilder<EarleyStateSet>();
    sets.add(e);
  }

  private process1(i: Int, chars: List<String>, codes: List<Int>): Void {
    var ichar = chars.getOr(i, "\0");
    var icode = codes.getOr(i, 0);
    var i1code = codes.getOr(i+1, 0);
    var last = sets[i];
    var next = sets[i+1];
    var inc = 0;
    for (var j = 0; j < last.length; j += inc) {
      inc = 1;
      var item = last[j];
      var itemDot = item.dot;
      var itemLen = item.ents.length;
      if (item.dot < itemLen) {
        var ent = item.ents[itemDot];
        if (ent.isTest()) {
          if (ent.check(icode)) {
            var more = true;
            var k = 1;
            while (more) {
              var nextEnt = item.ents.getOr(k + itemDot, nonTestItemEntry);
              if (nextEnt.isTest()) {
                if (nextEnt.check(codes.getOr(i+k, -1))) {
                  k += 1;
                } else {
                  k = 0;
                  more = false;
                }
              } else {
                more = false;
              }
            }
            if (k == 1) {
              next.add(item.advanceWithChar(ichar));
            } else if (k > 1) {
              var b = new ListBuilder<String>();
              b.add(ichar);
              for (var l = 1; l < k; l++) {
                b.add(chars.getOr(i+l, ""));
              }
              var s = b.join("", idString);
              sets.getOr(i+k, last).add(item.advanceWithString(k, s));
            }
          }
        } else {
          var name = ent.name();
          if (name == "%border") {
            if (!wordCharCodes[i1code] || !wordCharCodes[icode]) {
              last.add(item.advance());
            }
          } else {
            var found = byName[name];
            var flen = found.length;
            var noMagic = true;
            for (var k = 0; k < flen; k++) {
              var cur = found[k];
              var itemFound = cur.toItem(i);
              last.add(itemFound);
              if (nullable[cur.id]) {
                var magic = item.advance();
                last.add(magic);
                noMagic = false;
              }
            }
          }
        }
      } else {
        var olds = sets[item.start].nexts.getOr(item.name, new ListBuilder<Item>());
        var olen = olds.length;
        for (var k = 0; k < olen; k++) {
          last.add(olds[k].advanceWithItem(item));
        }
      }
    }
  }

  private string(str: String): EarleyStateSet | Bubble {
    var config = sets[0].config;
    var chars = str.split("");
    var codes = chars.map(ord);
    var len = chars.length;
    var ret = sets[0];
    for (var i = 0; i < len; i++) {
      ret = new EarleyStateSet(config);
      sets.add(ret);
    }
    var num = 0;
    sets.add(new EarleyStateSet(config));
    var ln = 1;
    var col = 1;
    for (var i = 0; i < len; i++) {
      if (chars[i] == "\n") {
        ln += 1;
        col = 1;
      } else {
        col += 1;
      }
      process1(i, chars, codes);
      var j = i;
      while (sets[j].length == 0) {
        if (j == len) {
          console.log("error at Ln ${ln.toString()}, Col ${col.toString()}");
          return ret;
        }
        j += 1;
      }
      num += sets[i].clear();
    }
    process1(len, [], []);
    return ret;
  }

  public trees(src: String): Listed<Tree> {
    var last = string(src);
    var ret = new ListBuilder<Tree>();
    for (var i = 0; i < last.length; i++) {
      var cur = last[i];
      if (cur.name == start && cur.start == 0 && cur.dot == cur.ents.length) {
        ret.addAll(cur.toTree());
      }
    }
    return ret;
  }
}

export class LexerEarley extends Earley {
  private start: String;
  private nullable: DenseBitVector;
  private byName: Mapped<String, Listed<Rule>>;
  private sets: ListBuilder<EarleyStateSet>;
  private lexer: Lexer;

  public constructor(s: String, n: DenseBitVector, e: EarleyStateSet, b: Mapped<String, Listed<Rule>>, l: Lexer): Void {
    start = s;
    nullable = n;
    byName = b;
    sets = new ListBuilder<EarleyStateSet>();
    sets.add(e);
    lexer = l;
  }

  private process1(i: Int, chars: List<String>, codes: List<Int>): Int {
    var last = sets[i];
    var start = last.length;
    for (var j = 0; j < last.length; j++) {
      var item = last[j];
      var itemDot = item.dot;
      var itemLen = item.ents.length;
      if (item.dot < itemLen) {
        var ent = item.ents[itemDot];
        if (!ent.isTest()) {
          var name = ent.name();
          if (name != "%border") {
            var found = byName[name];
            var flen = found.length;
            var noMagic = true;
            for (var k = 0; k < flen; k++) {
              var cur = found[k];
              var itemFound = cur.toItem(i);
              last.add(itemFound);
              if (nullable[cur.id]) {
                var magic = item.advance();
                last.add(magic);
                noMagic = false;
              }
            }
          }
        }
      } else {
        var olds = sets[item.start].nexts.getOr(item.name, new ListBuilder<Item>());
        var olen = olds.length;
        for (var k = 0; k < olen; k++) {
          last.add(olds[k].advanceWithItem(item));
        }
      }
    }
    return last.length - start;
  }

  private string(str: String): EarleyStateSet | Bubble {
    var config = sets[0].config;
    var chars = str.split("");
    var codes = chars.map(ord);
    var len = chars.length;
    for (var i = 1; i <= len; i++) {
      sets.add(new EarleyStateSet(config));
    }
    var all = lexer.nfa.run(chars);
    for (var i = 0; i < all.length; i++) {
      var sub = all[i];
      for (var j = 0; j < sub.length; j++) {
        var vj = sub[j];
        var s = new ListBuilder<String>();
        for (var k = i; k < vj.value; k++) {
          s.add(chars[k]);
        }
        var s = s.join("", idString);
        var t = new Token(s);
        var item = lexer.lookup(vj.key).toItem(i).asOnlyWith(t);
        // console.log("[${i.toString()} .. ${vj.value.toString()}] = ${s}")
        sets[vj.value].add(item);
      }
    }
    var num = 0;
    var ln = 1;
    var col = 1;
    var last = [1, 1];
    for (var i = 0; i < len; i++) {
      if (i != 0) {
        num += sets[i - 1].clear();
      }
      if (chars[i] == "\n") {
        ln += 1;
        col = 1;
      } else {
        col += 1;
      }
      var added = process1(i, chars, codes);
      if (added != 0) {
        last = [ln, col, i];
      }
    }
    return sets[sets.length - 2];
  }

  public trees(src: String): Listed<Tree> {
    var last = string(src);
    var ret = new ListBuilder<Tree>();
    for (var i = 0; i < last.length; i++) {
      var cur = last[i];
      if (cur.name == start && cur.start == 0 && cur.dot == cur.ents.length) {
        ret.addAll(cur.toTree());
      }
    }
    return ret;
  }
}
