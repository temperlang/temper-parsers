
let {...} = import("../../regex/nfa");
let {...} = import("./result");

export class Cache {
  public n: Int;
  public chars: Listed<String>;
  public nfa: NFA;
  public rules: MapBuilder<String, Normal>;
  public max: Int;
  public results: MapBuilder<Int, Result> = new MapBuilder<Int, Result>();
  public best: Int = -1;
  public cache: MapBuilder<String, Result> = new MapBuilder<String, Result>();

  public get head(): Int {
    return n;
  }

  public set head(value: Int): Void {
    if (value > best) {
      best = value;
    }
    n = value;
  }
}

export interface Normal {
  public id: Int;

  public check(cache: Cache): Result;
}

export class NormalOr extends Normal {
  public id: Int;
  public v1: Normal;
  public v2: Normal;
  
  public check(cache: Cache): Result {
    var init = cache.head;
    var r1 = v1.check(cache);
    var mid = cache.head;
    cache.head = init;
    var r2 = v2.check(cache);
    if (r1.stop >= r2.stop) {
      cache.head = mid;
      return r1;
    } else {
      return r2;
    }
  }
}

export class NormalAnd extends Normal {
  public id: Int;
  public v1: Normal;
  public v2: Normal;
  
  public check(cache: Cache): Result {
    var pos = cache.head;
    var r1 = v1.check(cache);
    if (r1.stop < 0) {
      cache.head = pos;
      return r1;
    }
    var r2 = v2.check(cache);
    return new ResultCons(r2.stop, r1, r2);
  }
}

export class NormalTerm extends Normal {
  public id: Int;
  public name: String;

  public check(cache: Cache): Result {
    var rname = cache.nfa.runFromName(name, cache.chars, cache.head);
    if (rname <= cache.head) {
      return new ResultError(-1, name);
    } else {
      var got = cache.head;
      cache.head = rname;
      return new ResultToken(rname, got);
    }
  }
}

export class NormalEmpty extends Normal {
  public id: Int;

  public check(cache: Cache): Result {
    return new ResultEmpty(cache.head);
  }
}

export class NormalNode extends Normal {
  public id: Int;
  public name: String;
  public next: Normal;

  public check(cache: Cache): Result {
    var got = next.check(cache);
    var ret = new ResultNode(got.stop, name, got);
    return ret;  
  }
}

var notDone = new ResultError(-1, "not-done");
var notHere = new ResultError(-1, "not-here");

export class NormalLink extends Normal {
  public id: Int;
  public name: String;

  public check(cache: Cache): Result {
    var save = cache.head;
    var hash = "${id.toString()},${save.toString()}";
    var cached = cache.cache.getOr(hash, notHere);
    if (cached != notHere) {
      cache.head = cached.stop;
      return cached;
    }
    var got = cache.rules.getOr(name, noNormal).check(cache);
    cache.cache[hash] = got;
    return got;
  }
}

export var noNormal = new NormalEmpty(-1);
export var noRecursive = new NormalEmpty(-1);
