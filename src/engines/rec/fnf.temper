
let {...} = import("../../common/rules");
let {...} = import("../../common/tree");
let {...} = import("../../regex/nfa");
let {...} = import("../engine");
let {...} = import("./result");
let {...} = import("./normal");

export class FNFRec extends Engine {
  private start: String;
  private rules: Rules;
  private nfa: NFA;
  private byId: ListBuilder<Normal>;
  private byName: MapBuilder<String, Normal>;
  private normalEmpty: Normal;

  public constructor(s: String, r: Rules, n: NFA): Void {
    start = s;
    rules = r;
    nfa = n;
    byId = new ListBuilder<Normal>();
    byName = new MapBuilder<String, Normal>();
    normalEmpty = new NormalEmpty(byId.length);
    byId.add(normalEmpty);
    translateName(s);
  }

  private makeNormalOr(a: Normal, b: Normal): Normal {
    var ret = new NormalOr(byId.length, a, b);
    byId.add(ret);
    return ret;
  }

  private makeNormalAnd(a: Normal, b: Normal): Normal {
    var ret = new NormalAnd(byId.length, a, b);
    byId.add(ret);
    return ret;
  }

  private makeNormalTerm(a: String): Normal {
    var ret = new NormalTerm(byId.length, a);
    byId.add(ret);
    return ret;
  }

  private makeNormalEmpty(): Normal {
    return normalEmpty;
  }

  private makeNormalLink(rule: String): Normal {
    var ret = new NormalLink(byId.length, rule);
    byId.add(ret);
    return ret;
  }

  private makeNormalNode(name: String, next: Normal): Normal {
    var ret = new NormalNode(byId.length, name, next);
    byId.add(ret);
    return ret;
  }

  private makeNormalIgnore(next: Normal): Normal {
    var ret = new NormalIgnore(byId.length, next);
    byId.add(ret);
    return ret;
  }

  private makeNormalLink(rule: String): Normal {
    var ret = new NormalLink(byId.length, rule);
    byId.add(ret);
    return ret;
  }

  private translatePart(part: RulePart): Normal {
    if (part.isString) {
      console.log("{ \"isString\" = true, \"data\" = \"${part.data}\" }");
      bubble();
      return makeNormalEmpty();
    } else {
      translateName(part.data);
      return makeNormalLink(part.data);
    }
  }

  private translateRule(rule: Rule): Normal {
    if (rule.lex) {
      return makeNormalTerm(rule.name);
    }
    // console.log(rule.name);
    var len = rule.parts.length;
    if (len == 0) {
      return makeNormalEmpty();
    }
    var cur = translatePart(rule.parts[len-1]);
    for (var i = rule.parts.length-2; i >= 0; i--) {
      var part = rule.parts[i];
      var translation = translatePart(part);
      cur = makeNormalAnd(translation, cur);
    }
    if (rule.mode == "%ignore") {
      return makeNormalIgnore(cur);
    } else if (rule.mode == "%expand") {
      return cur;
    } else {
      return makeNormalNode(rule.mode, cur);
    }
    return cur;
  }

  private translateName(name: String): Void {
    var got = rules.byName[name];
    if (byName.getOr(name, noNormal) == noNormal) {
      byName[name] = noRecursive;
      var cur = translateRule(got[0]);
      for (var i = 1; i < got.length; i++) {
        var rule = got[i];
        var translated = translateRule(rule);
        cur = makeNormalOr(translated, cur);
      }
      byName[name] = cur;
    }
  }

  public trees(src: String): Listed<Tree> {
    var cache = new Cache(0, src.split(""), nfa, byName, byId.length);
    var res = byName[start].check(cache);
    if (res.stop != cache.chars.length) {
      console.log("${cache.head.toString()} & ${cache.best.toString()} / ${cache.chars.length.toString()}");
    }
    return [new Node(start, res.toTrees(cache.chars)).as<Tree>()];
  }
}
