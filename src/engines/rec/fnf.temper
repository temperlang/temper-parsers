
let {...} = import("../../common/rules");
let {...} = import("../../common/tree");
let {...} = import("../../regex/nfa");
let {...} = import("../engine");
let {...} = import("./normal");

export class FNFRec extends Engine {
  private start: String;
  private rules: Rules;
  private nfa: NFA;
  private byId: ListBuilder<Normal>;
  private byName: MapBuilder<String, Normal>;
  private normalEmpty: Normal;

  public constructor(s: String, r: Rules, n: NFA): Void {
    start = s;
    rules = r;
    nfa = n;
    byId = new ListBuilder<Normal>();
    byName = new MapBuilder<String, Normal>();
    normalEmpty = new NormalEmpty(byId.length);
    byId.add(normalEmpty);
    translateName(s);
    // for (var i = 0; i < rules.rules.length; i++) {
    //   var rule = rules.rules[i];
    //   var named = byName.getOr(rule.name, noNormal);
    //   var translation = translateRule(rule);
    //   if (named == noNormal) {
    //     byName[rule.name] = translation;
    //   } else {
    //     byName[rule.name] = makeNormalOr(named, translation);
    //   }
    // }
  }

  private makeNormalOr(a: Normal, b: Normal): Normal {
    var ret = new NormalOr(byId.length, a, b);
    byId.add(ret);
    return ret;
  }

  private makeNormalAnd(a: Normal, b: Normal): Normal {
    var ret = new NormalAnd(byId.length, a, b);
    byId.add(ret);
    return ret;
  }

  private makeNormalTerm(a: String): Normal {
    var ret = new NormalTerm(byId.length, a);
    byId.add(ret);
    return ret;
  }

  private makeNormalEmpty(): Normal {
    return normalEmpty;
  }

  private makeNormalLink(rule: String): Normal {
    var ret = new NormalLink(byId.length, rule);
    byId.add(ret);
    return ret;
  }

  private translatePart(part: RulePart): Normal {
    if (part.isString) {
      console.log("{ \"isString\" = true, \"data\" = \"${part.data}\" }");
      bubble();
      return makeNormalEmpty();
    } else {
      translateName(part.data);
      return makeNormalLink(part.data);
    }
  }

  private translateRule(rule: Rule): Normal {
    if (rule.lex) {
      return makeNormalTerm(rule.name);
    }
    // console.log(rule.name);
    if (rule.parts.length == 0) {
      return makeNormalEmpty();
    }
    var len = rule.parts.length;
    var cur = translatePart(rule.parts[len-1]);
    for (var i = rule.parts.length-2; i >= 0; i--) {
      var part = rule.parts[i];
      var translation = translatePart(part);
      cur = makeNormalAnd(translation, cur);
    }
    return cur;
  }

  private translateName(name: String): Void {
    var got = rules.byName[name];
    if (byName.getOr(name, noNormal) == noNormal) {
      byName[name] = noRecursive;
      var cur = translateRule(got[0]);
      for (var i = 1; i < got.length; i++) {
        var rule = got[i];
        var translated = translateRule(rule);
        cur = makeNormalOr(translated, cur);
      }
      byName[name] = cur;
    }
  }

  public trees(src: String): Listed<Tree> {
    var cache = new Cache(
      n = 0,
      chars = src.split(""),
      nfa = nfa,
      results = new MapBuilder<Int, Result>(),
      rules = byName,
    );
    var res = byName[start].check(cache);
    console.log("${res.stop.toString()} / ${cache.chars.length.toString()}");
    return [res.trees];
  }
}
