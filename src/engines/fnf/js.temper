
let {...} = import("../../common/rules");
let {...} = import("./normal");

let idString(s: String): String {
  return s;
}

export class GenJS {
  private buf: ListBuilder<String>;
  private name: MapBuilder<String, Normal>;
  private hashes: Int;
  private sets: ListBuilder<NormalCharSet>;
  private depth: Int;

  public constructor(byName: MapBuilder<String, Normal>) {
    buf = new ListBuilder<String>();
    name = byName;
    hashes = 0;
    sets = new ListBuilder<String>();
    depth = 0;
  }

  private f(n: Normal): String {
    return "f${n.id.toString()}";
  }

  public push(s: String): Void {
    if (s == "") {
      buf.add(s);
    } else {
      for (var i = 0; i < depth; i++) {
        s = "  ${s}";
      }
      buf.add(s);
    }
  }

  public addOr(n: NormalOr): Void {
    push("const init = this.head;");
    push("const r1 = this.${f(n.v1)}();");
    push("const mid = this.head;");
    push("this.head = init;");
    push("const r2 = this.${f(n.v2)}();");
    push("if (r1.stop > r2.stop) {");
    depth += 1;
    push("this.head = mid;");
    push("return r1;");
    depth -= 1;
    push("} else {");
    depth += 1;
    push("return r2;");
    depth -= 1;
    push("}");
  }

  public addAnd(n: NormalAnd): Void {
    push("const pos = this.head;");
    push("const r1 = this.${f(n.v1)}();");
    push("if (r1.stop < 0) {");
    depth += 1;
    push("this.head = pos;");
    push("return r1;");
    depth -= 1;
    push("}");
    push("const r2 = this.${f(n.v2)}();");
    push("return new ResultCons(r2.stop, r1, r2);");
  }

  public addEmpty(n: NormalEmpty): Void {
    push("return new ResultEmpty(this.head);");
  }

  public addNode(n: NormalNode): Void {
    push("const got = this.${f(n.next)}();");
    push("return new ResultNode(got.stop, \"${n.name}\", got)");
  }

  public addIgnore(n: NormalIgnore): Void {
    push("return new ResultIgnore(this.${f(n.next)}().stop);");
  }

  public addToken(n: NormalToken): Void {
    push("const start = this.head;");
    push("const got = this.${f(n.next)}();");
    push("return new ResultToken(got.stop, start);");
  }

  public addCharSet(n: NormalCharSet): Void {
    sets.add(n);
    push("const head = this.head;");
    push("if (c${n.id.toString()}[this.chars[head]]) {");
    depth += 1;
    push("const stop = head + 1;");
    push("if (stop >= this.best) {");
    depth += 1;
    push("this.best = stop;");
    depth -= 1;
    push("}");
    push("this.head = stop;");
    push("return new ResultToken(stop, head);");
    depth -= 1;
    push("}");
    push("return notFound;");
  }

  public addLink(n: NormalLink): Void {
    push("const head = this.head;");
    push("const hash = ${hashes.toString()} * this.chars.length + head;");
    hashes += 1;
    push("const cached = this.cache.get(hash);");
    push("if (cached !== undefined) {");
    depth += 1;
    push("this.head = cached.stop;");
    push("return cached;");
    depth -= 1;
    push("}");
    push("const got = this.${f(name[n.name])}();");
    push("this.cache.set(hash, got);");
    push("return got;");
  }

  public add(n: Normal): Void {
    push("");
    push("f${n.id.toString()}() {");
    depth += 1;
    match (n) {
      is NormalOr -> addOr(n);
      is NormalAnd -> addAnd(n);
      is NormalCharSet -> addCharSet(n);
      is NormalEmpty -> addEmpty(n);
      is NormalNode -> addNode(n);
      is NormalIgnore -> addIgnore(n);
      is NormalToken -> addToken(n);
      is NormalLink -> addLink(n);
    }
    depth -= 1;
    push("  }");
  }

  public start(s: String): Void {
    push("import {ResultNode, ResultToken, ResultIgnore, ResultEmpty, ResultCons, ResultError} from 'temper-parsers/src/engines/fnf/result.js';");
    push("const notFound = new ResultError(-1, 'not-found');");
    push("const notToken = new ResultError(-1, 'not-token');");
    push("export class Parser {");
    depth += 1;
    push("parse(src) {");
    depth += 1;
    push("this.head = 0;");
    push("this.best = -1;");
    push("this.chars = src;");
    push("this.cache = new Map();");
    push("return this.${f(name[s])}();");
    depth -= 1;
    push("}");
  }

  public stop(): Void {
    push("}");
    depth -= 1;

    for (var i = 0; i < sets.length; i++) {
      var n = sets[i];
      push("");
      var c = "c${n.id.toString()}";
      push("const ${c} = [];");
      var split = n.str.split("");
      for (var j = 0; j < split.length; j++) {
        push("${c}[String.fromCharCode(${split[j].codePoints.read().toString()})] = true;")
      }
    }
  }

  public out(): String {
    return buf.join("\n", idString);
  }
}
