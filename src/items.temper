
let {...} = import("./tree.temper");

export interface ItemPart {
  public isTest(): Boolean;
  public name(): String;
  public check(c: Int): Boolean;
  public toString(): String;
}

export class ItemPartItem extends ItemPart {
  public rule: String;
  
  public isTest(): Boolean {
    return false;
  }

  public name(): String {
    return rule;
  }

  public check(c: Int): Boolean {
    return false;
  }

  public toString(): String {
    return rule;
  }
}

export class ItemPartSet extends ItemPart {
  public vals: List<String>;
  private bits: DenseBitVector;

  public constructor(args: List<String>): Void {
    vals = args;
    bits = new DenseBitVector(128);
    for (var i = 0; i < args.length; i++) {
      bits[args[i].codePoints.read()] = true;
    }
  }
  
  public isTest(): Boolean {
    return true;
  }

  public name(): String {
    return "FAKE ${vals.join(" | ") { (s);; s }}";
  }

  public check(c: Int): Boolean {
    return bits[c];
  }

  public toString(): String {
    var joined = vals.join("|") { (s);; s };
    return "/${joined}/";
  }
}

export class Item {
  public name: String;
  public ents: List<ItemPart>;
  public dot: Int;
  public start: Int;
  public id: Int;
  public last: List<Item>;
  public trees: Listed<Tree>;

  public toString(): String {
    var build = new ListBuilder<String>();
    build.add(name);
    build.add("(start: ${start.toString()})");
    build.add("->");
    for (var i = 0; i < dot; i++) {
      build.add(ents[i].toString());
    }
    build.add("*");
    for (var i = dot; i < ents.length; i++) {
      build.add(ents[i].toString());
    }
    return build.join(" ") { (s);; s };
  }

  public advanceWith(got: Listed<Tree>): Item {
    return new Item(name, ents, dot + 1, start, id, [this], got);
  }

  public advance(): Item {
    return new Item(name, ents, dot + 1, start, id, [this], []);
  }

  public eq(other: Item): Boolean {
    return id == other.id && start == other.start && dot == other.dot; 
  }

  public toTree(cons: Listed<fn(Listed<Tree>): Listed<Tree>>): Listed<Tree> {
    var realTrees = new ListBuilder<Tree>();
    let rec(item: Item): Void {
      if (item.last.length != 0) {
        rec(item.last[0]);
      }
      realTrees.addAll(item.trees);
    }
    rec(this);
    return cons[id](realTrees.toList());
  }
}
