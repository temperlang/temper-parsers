
let {...} = import("./tree");

export interface ItemPart {
  public isTest(): Boolean;
  public name(): String;
  public check(t: Token): Boolean;
  public toString(): String;
}

export class ItemPartItem extends ItemPart {
  public rule: String;
  
  public isTest(): Boolean {
    return false;
  }

  public name(): String {
    return rule;
  }

  public check(c: Int): Boolean {
    return false;
  }

  public toString(): String {
    return rule;
  }
}

export class ItemPartSet extends ItemPart {
  private vals: Listed<Token>;
  private bits: DenseBitVector;

  public constructor(args: List<Token>): Void {
    vals = args;
  }
  
  public isTest(): Boolean {
    return true;
  }

  public name(): String {
    return "";
  }

  public check(t: Token): Boolean {
    var nvals = vals.length;
    for (var i = 0; i < nvals; i++) {
      var cur = vals[i];
      if (cur.value == t.value) {
        return true;
      }
    }
    return false;
  }

  public toString(): String {
    var joined = vals.join("|") { (s);; s.toString() };
    return "/${joined}/";
  }
}

var noTrees: List<Tree> = [];

export interface Item {
  public name: String;
  public ents: List<ItemPart>;
  public dot: Int;
  public start: Int;
  public id: Int;

  public addTreesTo(b: ListBuilder<Tree>): Void;

  public toTree(cons: Listed<fn(Listed<Tree>): Listed<Tree>>): Listed<Tree>;
  
  public advanceWithSingle(got: Tree): Item;
  public advanceWith(got: Listed<Tree>): Item;
  public advance(): Item;
} 

export class FirstItem extends Item {
  public name: String;
  public ents: List<ItemPart>;
  public dot: Int;
  public start: Int;
  public id: Int;

  public addTreesTo(b: ListBuilder<Tree>): Void {}
  
  public toTree(cons: Listed<fn(Listed<Tree>): Listed<Tree>>): Listed<Tree> {
    return cons[id](noTrees);
  }

  public advanceWithSingle(got: Tree): Item {
    return new RestItem(name, ents, dot + 1, start, id, this, [got]);
  }

  public advanceWith(got: Listed<Tree>): Item {
    return new RestItem(name, ents, dot + 1, start, id, this, got);
  }

  public advance(): Item {
    return new RestItem(name, ents, dot + 1, start, id, this, noTrees);
  }
}

export class RestItem extends Item {
  public name: String;
  public ents: List<ItemPart>;
  public dot: Int;
  public start: Int;
  public id: Int;
  private last: Item;
  private trees: Listed<Tree>;

  public toString(): String {
    var build = new ListBuilder<String>();
    build.add(name);
    build.add("(start: ${start.toString()})");
    build.add("->");
    for (var i = 0; i < dot; i++) {
      build.add(ents[i].toString());
    }
    build.add("*");
    for (var i = dot; i < ents.length; i++) {
      build.add(ents[i].toString());
    }
    return build.join(" ") { (s);; s };
  }

  public advanceWithSingle(got: Tree): Item {
    return new RestItem(name, ents, dot + 1, start, id, this, [got]);
  }

  public advanceWith(got: Listed<Tree>): Item {
    return new RestItem(name, ents, dot + 1, start, id, this, got);
  }

  public advance(): Item {
    return new RestItem(name, ents, dot + 1, start, id, this, noTrees);
  }

  public eq(other: Item): Boolean {
    return id == other.id && start == other.start && dot == other.dot; 
  }

  public addTreesTo(b: ListBuilder<Tree>): Void {
    last.addTreesTo(b);
    b.addAll(trees);
  }

  public toTree(cons: Listed<fn(Listed<Tree>): Listed<Tree>>): Listed<Tree> {
    var b = new ListBuilder<Tree>();
    addTreesTo(b);
    return cons[id](b);
  }
}
