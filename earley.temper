
let {...} = import("std/regex");
let {...} = import('./tree.temper');

interface Object {
  public isItem(other: String): Boolean;
  public isString(other: String): Boolean;
  public toString(): String;
}

class ObjectString extends Object {
  public data: String;

  public isItem(other: String): Boolean {
    return false;
  }

  public isString(other: String): Boolean {
    return data == other;
  }

  public toString(): String {
    return "\"${data}\"";
  }
}

class ObjectItem extends Object {
  public name: String;

  public isItem(other: String): Boolean {
    return name == other;
  }

  public isString(other: String): Boolean {
    return false;
  }

  public toString(): String {
    return "$${name}";
  }
}

interface ItemPart {
  public isTest(): Boolean;
  public name(): String;
  public check(s: String): Boolean;
  public toString(): String;
}

class ItemPartItem extends ItemPart {
  public rule: String;
  
  public isTest(): Boolean {
    return false;
  }

  public name(): String {
    return rule;
  }

  public check(s: String): Boolean {
    return false;
  }

  public toString(): String {
    return rule;
  }
}

class ItemPartSet extends ItemPart {
  public vals: List<String>;
  
  public isTest(): Boolean {
    return true;
  }

  public name(): String {
    return "";
  }

  public check(s: String): Boolean {
    for (var i = 0; i < vals.length; i++) {
      if (vals[i] == s) {
        return true;
      }
    }
    return false;
  }

  public toString(): String {
    var joined = vals.join("|") { (s);; s };
    return "/${joined}/";
  }
}

class Item {
  public name: String;
  public ents: List<ItemPart>;
  public dot: Int;
  public start: Int;
  public id: Int;
  public trees: List<Tree>;

  public toString(): String {
    var build = new ListBuilder<String>();
    build.add(name);
    build.add("(${start.toString()})");
    build.add("->");
    for (var i = 0; i < dot; i++) {
      build.add(ents[i].toString());
    }
    build.add("*");
    for (var i = dot; i < ents.length; i++) {
      build.add(ents[i].toString());
    }
    return build.join(" ") { (s);; s };
  }

  public advance(tree: Tree): Item {
    var next = new ListBuilder<Tree>();
    next.addAll(trees);
    next.add(tree);
    return new Item(name, ents, dot + 1, start, id, next.toList());
  }

  public eq(other: Item): Boolean {
    return id == other.id && start == other.start && dot == other.dot; 
  }
}

class StateSets {
  public rules: Rules;
  public sets: ListBuilder<ListBuilder<Item>>;

  public constructor(ru: Rules, start: String): Void {
    rules = ru;
    sets = new ListBuilder<ListBuilder<Item>>();
    sets.add(new ListBuilder<Item>());
    var found = rules.find(start);
    for (var i = 0; i < found.length; i++) {
      sets[0].add(found[i].toItem(0));
    }
  }

  public toString(): String {
    var build = new ListBuilder<String>();
    for (var i = 0; i < sets.length; i++) {
      build.add("=== ${i.toString()} ===");
      for (var j = 0; j < sets[i].length; j++) {
        build.add(sets[i][j].toString());
      }
    }
    return build.join("\n") { (s);; s };
  }

  public add(setv: ListBuilder<Item>, next: Item): Boolean {
    for (var i = 0; i < setv.length; i++) {
      if (setv[i].eq(next)) {
        return false;
      }
    }
    setv.add(next);
    return true;
  }

  public string(input: List<String>): Void {
    for (var i = 0; i < input.length; i++) {
      var next = new ListBuilder<Item>();
      var more = true;
      while (more) {
        more = false;
        for (var j = 0; j < sets[i].length; j++) {
          var item = sets[i][j];
          if (item.dot < item.ents.length) {
            var ent = item.ents[item.dot];
            if (ent.isTest()) {
              // scan
              if (ent.check(input[i])) {
                add(next, item.advance(new Token(input[i])));
              }
            } else {
              // predict
              var found = rules.find(ent.name());
              for (var k = 0; k < found.length; k++) {
                var next = found[k].toItem(i);
                if (add(sets[i], next)) {
                  more = true;
                }
              }
            }
          } else {
            // complete
            for (var k = 0; k < sets[item.start].length; k++) {
              var old = sets[item.start][k];
              if (old.dot < old.ents.length) {
                var ent = old.ents[old.dot];
                if (!ent.isTest() && ent.name() == item.name) {
                  if (add(sets[i], old.advance(new Node(item.name, item.trees)))) {
                    more = true;
                  }
                }
              }
            }
          }
        }
      }
      sets.add(next);
    }
    var i = sets.length-1;
    for (var j = 0; j < sets[i].length; j++) {
      var item = sets[i][j];
      for (var k = 0; k < sets[item.start].length; k++) {
        var old = sets[item.start][k];
        if (old.dot < old.ents.length) {
          var ent = old.ents[old.dot];
          if (!ent.isTest() && ent.name() == item.name) {
            add(sets[i], old.advance(new Node(item.name, item.trees)));
          }
        }
      }
    }
  }
}

class RulePart {
  public isString: Boolean;
  public data: String;

  public toString(): String {
    if (isString) {
      return "\"${data}\"";
    } else {
      return data;
    }
  }
}

class Rule {
  public name: String;
  public parts: List<RulePart>;
  public id: Int;

  public constructor(s: String, ls: List<RulePart>, i: Int): Void {
    name = s;
    parts = ls;
    id = i;
  }

  public toString(): String {
    var build = new ListBuilder<String>();
    build.add(name);
    build.add("->");
    for (var i = 0; i < parts.length; i++) {
      build.add(parts[i].toString());
    }
    return build.join(" ") { (s);; s };
  }

  public toItem(at: Int): Item {
    var iparts = new ListBuilder<ItemPart>();
    for (var i = 0; i < parts.length; i++) {
      if (parts[i].isString) {
        iparts.add(new ItemPartSet(parts[i].data.split("")));
      } else {
        iparts.add(new ItemPartItem(parts[i].data));
      }
    }
    return new Item(name, iparts.toList(), 0, at, id, []);
  }
}

class Rules {
  public rules: ListBuilder<Rule>; 

  public constructor(): Void {
    rules = new ListBuilder<Rule>();
  }

  public add(rule: Rule): Void {
    rules.add(rule);
  }

  public toString(): String {
    return rules.join("\n", fn(rule: Rule): String {
      return rule.toString();
    });
  }

  public find(name: String): List<Rule> {
    var ret = new ListBuilder<Rule>();
    for (var i = 0; i < rules.length; i++) {
      if (rules[i].name == name) {
        ret.add(rules[i]);
      }
    }
    return ret.toList();
  }
}

export class Earley {
  public rname: String;
  public parts: ListBuilder<ListBuilder<RulePart>>;
  public rules: Rules;
  public nid: Int;

  public constructor(): Void {
    rname = "";
    parts = new ListBuilder<ListBuilder<RulePart>>();
    rules = new Rules();
    nid = 0;
  }

  public name(s: String): Earley {
    for (var i = 0; i < parts.length; i++) {
      rules.add(new Rule(rname, parts[i].toList(), nid++));
    }
    rname = s;
    parts = new ListBuilder<ListBuilder<RulePart>>();
    return this;
  }

  public seq(): Earley {
    parts.add(new ListBuilder<RulePart>());
    return this;
  }

  public char(chr: String): Earley {
    parts[parts.length-1].add(new RulePart(true, chr));
    return this;
  }

  public rule(xname: String): Earley {
    parts[parts.length-1].add(new RulePart(false, xname));
    return this;
  }

  public debug(start: String, src: String): Void {
    var sets = new StateSets(build(), start);
    sets.string(src.split(""));
    for (var j = 0; j < sets.sets.length; j++) {
      console.log("=== ${j.toString()} ===");
      var last = sets.sets[j];
      for (var i = 0; i < last.length; i++) {
        console.log(last[i].toString());
      }
    }
  }

  public parse(start: String, src: String): Void {
    var sets = new StateSets(build(), start);
    sets.string(src.split(""));
    var last = sets.sets[sets.sets.length-1];
    for (var i = 0; i < last.length; i++) {
      console.log(last[i].toString());
    }
  }

  public trees(start: String, src: String): List<Tree> {
    var sets = new StateSets(build(), start);
    sets.string(src.split(""));
    var ret = new ListBuilder<Tree>();
    var last = sets.sets[sets.sets.length-1];
    for (var i = 0; i < last.length; i++) {
      var cur = last[i];
      if (cur.name == start && cur.start == 0 && cur.dot == cur.ents.length) {
        ret.add(new Node(cur.name, cur.trees));
      }
    }
    return ret.toList();
  }

  public build(): Rules {
    name("");
    return rules;
  }

  public toString(): String {
    return build().toString();
  }
}
